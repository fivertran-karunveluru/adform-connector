"""Adform API Connector for Fivetran Connector SDK.

This connector demonstrates how to fetch data from Adform APIs and upsert
it into a destination using the Fivetran Connector SDK.

The connector is designed to work with mocked API responses generated by Faker
for local development and CI. Real API methods are also implemented with
timeouts, retries and basic OAuth2 token handling.

References:
- SDK Technical Reference: https://fivetran.com/docs/connectors/connector-sdk/technical-reference#update
- SDK Best Practices: https://fivetran.com/docs/connectors/connector-sdk/best-practices
- Removing yield usage: https://fivetran.com/docs/connectors/connector-sdk/tutorials/removing-yield-usage
- Adform API Docs: https://www.adformhelp.com/hc/en-us/categories/14899730386065-API-Documentation
"""

from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional

import requests
from fivetran_connector_sdk import Connector
from fivetran_connector_sdk import Logging as log
from fivetran_connector_sdk import Operations as op


# Constants
API_BASE_URL = "https://api.adform.com"
AUTH_URL = "https://id.adform.com/sts/connect/token"
DEFAULT_TIMEOUT = 30
DEFAULT_RETRY_ATTEMPTS = 3
DEFAULT_PAGE_SIZE = 100
DEFAULT_INITIAL_SYNC_DAYS = 90


class SyncType(Enum):
    INITIAL = "initial"
    INCREMENTAL = "incremental"


@dataclass
class AdformConfig:
    """Configuration for Adform connector.

    All raw values arrive as strings in configuration.json; this class uses
    parsed/typed values to drive behavior.
    """

    client_id: str
    client_secret: str
    refresh_token: str
    adform_base_url: str = API_BASE_URL
    initial_sync_days: int = DEFAULT_INITIAL_SYNC_DAYS
    page_size: int = DEFAULT_PAGE_SIZE
    request_timeout_seconds: int = DEFAULT_TIMEOUT
    retry_attempts: int = DEFAULT_RETRY_ATTEMPTS
    enable_incremental_sync: bool = True
    enable_campaigns_sync: bool = True
    enable_lineitems_sync: bool = True
    enable_creatives_sync: bool = True
    enable_debug_logging: bool = False
    use_mock: bool = True


def _safe_int(value: Any, default: int) -> int:
    try:
        return int(str(value))
    except (ValueError, TypeError):
        return default


def _safe_bool(value: Any, default: bool) -> bool:
    return str(value).lower() == "true" if value is not None else default


def parse_configuration(configuration: dict) -> AdformConfig:
    """Parse configuration where all inputs are strings and coerce types.

    The configuration.json requires all values to be strings. This function
    converts them to appropriate Python types used internally.
    """

    return AdformConfig(
        client_id=str(configuration.get("client_id", "")).strip(),
        client_secret=str(configuration.get("client_secret", "")).strip(),
        refresh_token=str(configuration.get("refresh_token", "")).strip(),
        adform_base_url=str(configuration.get("adform_base_url", API_BASE_URL)).strip()
        or API_BASE_URL,
        initial_sync_days=_safe_int(
            configuration.get("initial_sync_days"), DEFAULT_INITIAL_SYNC_DAYS
        ),
        page_size=_safe_int(configuration.get("page_size"), DEFAULT_PAGE_SIZE),
        request_timeout_seconds=_safe_int(
            configuration.get("request_timeout_seconds"), DEFAULT_TIMEOUT
        ),
        retry_attempts=_safe_int(
            configuration.get("retry_attempts"), DEFAULT_RETRY_ATTEMPTS
        ),
        enable_incremental_sync=_safe_bool(
            configuration.get("enable_incremental_sync"), True
        ),
        enable_campaigns_sync=_safe_bool(
            configuration.get("enable_campaigns_sync"), True
        ),
        enable_lineitems_sync=_safe_bool(
            configuration.get("enable_lineitems_sync"), True
        ),
        enable_creatives_sync=_safe_bool(
            configuration.get("enable_creatives_sync"), True
        ),
        enable_debug_logging=_safe_bool(
            configuration.get("enable_debug_logging"), False
        ),
        use_mock=_safe_bool(configuration.get("use_mock"), True),
    )


def validate_configuration(config: AdformConfig) -> None:
    """Validate required configuration values.

    If `use_mock` is True, relax auth requirements since we won't call the live API.
    """

    if not (1 <= config.initial_sync_days <= 365):
        raise ValueError("initial_sync_days must be between 1 and 365")

    if not (1 <= config.page_size <= 1000):
        raise ValueError("page_size must be between 1 and 1000")

    if not (1 <= config.request_timeout_seconds <= 300):
        raise ValueError("request_timeout_seconds must be between 1 and 300")

    if not (1 <= config.retry_attempts <= 10):
        raise ValueError("retry_attempts must be between 1 and 10")

    # Only enforce credentials when not mocking
    if not config.use_mock:
        if not config.client_id:
            raise ValueError("client_id is required when use_mock is false")
        if not config.client_secret:
            raise ValueError("client_secret is required when use_mock is false")
        if not config.refresh_token:
            raise ValueError("refresh_token is required when use_mock is false")


def determine_sync_type(state: dict, enable_incremental: bool) -> SyncType:
    last_sync_time = state.get("last_sync_time")
    if last_sync_time and enable_incremental:
        return SyncType.INCREMENTAL
    return SyncType.INITIAL


def get_time_range(sync_type: SyncType, config: AdformConfig) -> Dict[str, str]:
    """Return an ISO-8601 time range dict for queries."""
    end_time = datetime.now().isoformat()
    if sync_type == SyncType.INCREMENTAL:
        # The caller will pass last_sync_time into API filters as needed.
        start_time = end_time
    else:
        start_time = (
            datetime.now() - timedelta(days=config.initial_sync_days)
        ).isoformat()
    return {"start": start_time, "end": end_time}


class AdformAPIClient:
    """Adform API client for live API interactions.

    By default, the connector uses mocked responses. Set `use_mock` to False to
    enable live API calls (requires valid OAuth2 credentials).
    """

    def __init__(self, config: AdformConfig):
        self.config = config
        self.base_url = config.adform_base_url.rstrip("/")
        self.session = requests.Session()
        self._access_token: Optional[str] = None

    def _headers(self) -> Dict[str, str]:
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Fivetran-Adform-Connector/1.0",
        }
        if self._access_token:
            headers["Authorization"] = f"Bearer {self._access_token}"
        return headers

    def authenticate(self) -> None:
        if self.config.use_mock:
            self._access_token = "mock-token"
            return

        data = {
            "grant_type": "refresh_token",
            "client_id": self.config.client_id,
            "client_secret": self.config.client_secret,
            "refresh_token": self.config.refresh_token,
        }

        for attempt in range(self.config.retry_attempts):
            try:
                resp = self.session.post(
                    AUTH_URL,
                    data=data,
                    timeout=self.config.request_timeout_seconds,
                )
                resp.raise_for_status()
                payload = resp.json()
                self._access_token = payload.get("access_token")
                if not self._access_token:
                    raise RuntimeError("No access_token in Adform auth response")
                return
            except requests.RequestException as exc:  # pragma: no cover - network paths
                if attempt == self.config.retry_attempts - 1:
                    log.severe(f"Adform auth failed after retries: {exc}")
                    raise RuntimeError(f"Adform auth failed: {exc}")

    def _request(
        self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        url = f"{self.base_url}{endpoint}"
        for attempt in range(self.config.retry_attempts):
            try:
                resp = self.session.request(
                    method=method,
                    url=url,
                    headers=self._headers(),
                    params=params or {},
                    timeout=self.config.request_timeout_seconds,
                )
                resp.raise_for_status()
                return resp.json()
            except requests.RequestException as exc:  # pragma: no cover - network paths
                if attempt == self.config.retry_attempts - 1:
                    log.severe(f"Adform API request failed after retries: {exc}")
                    raise RuntimeError(f"Adform API request failed: {exc}")

        return {}

    def list_campaigns(
        self, start: Optional[str] = None, end: Optional[str] = None, page: int = 1
    ) -> Dict[str, Any]:
        params = {"page": page, "pageSize": self.config.page_size}
        if start:
            params["startDateFrom"] = start
        if end:
            params["startDateTo"] = end
        return self._request("GET", "/v1/buyer/campaigns", params=params)

    def list_line_items(self, campaign_id: str, page: int = 1) -> Dict[str, Any]:
        params = {"page": page, "pageSize": self.config.page_size}
        return self._request(
            "GET", f"/v1/buyer/campaigns/{campaign_id}/lineitems", params=params
        )

    def list_creatives(self, campaign_id: str, page: int = 1) -> Dict[str, Any]:
        params = {"page": page, "pageSize": self.config.page_size}
        return self._request(
            "GET", f"/v1/buyer/campaigns/{campaign_id}/creatives", params=params
        )


class AdformDataProcessor:
    """Transform Adform API payloads into standardized records."""

    @staticmethod
    def ts_from(data: Dict[str, Any], fallback: Optional[str] = None) -> str:
        for key in ("updatedAt", "modifiedAt", "lastUpdated", "createdAt"):
            if data.get(key):
                return str(data[key])
        return fallback or datetime.now().isoformat()

    @staticmethod
    def process_campaign(c: Dict[str, Any]) -> Dict[str, Any]:
        return {
            "campaign_id": str(c.get("id", "")),
            "name": str(c.get("name", "")),
            "status": str(c.get("status", "")),
            "advertiser_id": str(c.get("advertiserId", "")),
            "start_date": str(c.get("startDate", "")),
            "end_date": str(c.get("endDate", "")),
            "budget": str(c.get("budget", "")),
            "timestamp": AdformDataProcessor.ts_from(c),
        }

    @staticmethod
    def process_line_item(li: Dict[str, Any], campaign_id: str) -> Dict[str, Any]:
        return {
            "line_item_id": str(li.get("id", "")),
            "campaign_id": str(campaign_id),
            "name": str(li.get("name", "")),
            "status": str(li.get("status", "")),
            "bid_strategy": str(li.get("bidStrategy", "")),
            "budget": str(li.get("budget", "")),
            "start_date": str(li.get("startDate", "")),
            "end_date": str(li.get("endDate", "")),
            "timestamp": AdformDataProcessor.ts_from(li),
        }

    @staticmethod
    def process_creative(cr: Dict[str, Any], campaign_id: str) -> Dict[str, Any]:
        size = cr.get("size")
        size_str = (
            f"{size.get('width')}x{size.get('height')}"
            if isinstance(size, dict)
            else str(size or "")
        )
        return {
            "creative_id": str(cr.get("id", "")),
            "campaign_id": str(campaign_id),
            "name": str(cr.get("name", "")),
            "format": str(cr.get("format", "")),
            "status": str(cr.get("status", "")),
            "size": size_str,
            "timestamp": AdformDataProcessor.ts_from(cr),
        }

    @staticmethod
    def sync_meta(
        scope: str, count: int, status: str = "success", error: str = ""
    ) -> Dict[str, Any]:
        ts = datetime.now().isoformat()
        return {
            "table_id": scope,
            "last_sync_time": ts,
            "total_records_synced": count,
            "sync_status": status,
            "error_message": error,
            "timestamp": ts,
        }


def schema(configuration: dict) -> List[Dict[str, Any]]:
    """Define destination tables and columns."""
    return [
        {
            "table": "campaigns",
            "primary_key": ["campaign_id"],
            "columns": {
                "campaign_id": "STRING",
                "name": "STRING",
                "status": "STRING",
                "advertiser_id": "STRING",
                "start_date": "STRING",
                "end_date": "STRING",
                "budget": "STRING",
                "timestamp": "STRING",
            },
        },
        {
            "table": "line_items",
            "primary_key": ["line_item_id"],
            "columns": {
                "line_item_id": "STRING",
                "campaign_id": "STRING",
                "name": "STRING",
                "status": "STRING",
                "bid_strategy": "STRING",
                "budget": "STRING",
                "start_date": "STRING",
                "end_date": "STRING",
                "timestamp": "STRING",
            },
        },
        {
            "table": "creatives",
            "primary_key": ["creative_id"],
            "columns": {
                "creative_id": "STRING",
                "campaign_id": "STRING",
                "name": "STRING",
                "format": "STRING",
                "status": "STRING",
                "size": "STRING",
                "timestamp": "STRING",
            },
        },
        {
            "table": "sync_metadata",
            "primary_key": ["table_id"],
            "columns": {
                "table_id": "STRING",
                "last_sync_time": "STRING",
                "total_records_synced": "INT",
                "sync_status": "STRING",
                "error_message": "STRING",
                "timestamp": "STRING",
            },
        },
    ]


def _iter_paginated(client_method, *args, **kwargs):
    """Simple pagination iterator expecting Adform-like paged responses.

    The mock returns a structure with `items` and `hasMore` or total/page fields.
    This iterator yields each page payload.
    """

    page = 1
    while True:
        payload = client_method(*args, page=page, **kwargs)
        if not payload:
            break
        yield payload

        has_more = False
        if isinstance(payload, dict):
            # Support both patterns: explicit flag or calculated
            has_more = bool(payload.get("hasMore"))
            total = payload.get("total")
            page_size = payload.get("pageSize") or payload.get("page_size")
            current_page = payload.get("page") or page
            if total and page_size and current_page:
                has_more = (current_page * page_size) < total

        if not has_more:
            break
        page += 1


def update(configuration: dict, state: dict) -> None:
    """Main sync for Adform connector."""
    log.info("Starting Adform connector sync")

    cfg = parse_configuration(configuration)
    validate_configuration(cfg)

    # Initialize client
    client = AdformAPIClient(cfg)

    # Use mock layer when requested by config or env
    use_mock_env = os.getenv("ADFORM_USE_MOCK")
    if use_mock_env is not None:
        cfg.use_mock = _safe_bool(use_mock_env, cfg.use_mock)

    if cfg.enable_debug_logging:
        log.info(
            f"Config(use_mock={cfg.use_mock}, page_size={cfg.page_size}, "
            f"incremental={cfg.enable_incremental_sync})"
        )

    if not cfg.use_mock:
        client.authenticate()

    sync_type = determine_sync_type(state, cfg.enable_incremental_sync)
    time_range = get_time_range(sync_type, cfg)

    processor = AdformDataProcessor()

    # Campaigns
    if cfg.enable_campaigns_sync:
        total_campaigns = 0
        for page_payload in _iter_paginated(
            client.list_campaigns, start=time_range["start"], end=time_range["end"]
        ):
            items = page_payload.get("items") or page_payload.get("campaigns") or []
            for c in items:
                op.upsert(table="campaigns", data=processor.process_campaign(c))
                total_campaigns += 1

        op.upsert(
            table="sync_metadata",
            data=processor.sync_meta("campaigns", total_campaigns),
        )
        log.info(f"Synced campaigns: {total_campaigns}")

    # Line items and creatives (per campaign) — only if we synced any campaigns
    # To avoid extra calls, we can re-list campaigns but in mock this is light-weight.
    if cfg.enable_lineitems_sync or cfg.enable_creatives_sync:
        campaign_ids: List[str] = []
        for page_payload in _iter_paginated(
            client.list_campaigns, start=time_range["start"], end=time_range["end"]
        ):
            items = page_payload.get("items") or page_payload.get("campaigns") or []
            for c in items:
                cid = str(c.get("id")) if c.get("id") is not None else None
                if cid:
                    campaign_ids.append(cid)

        # Line items
        if cfg.enable_lineitems_sync:
            total_li = 0
            for cid in campaign_ids:
                for page_payload in _iter_paginated(
                    client.list_line_items, campaign_id=cid
                ):
                    items = (
                        page_payload.get("items") or page_payload.get("lineItems") or []
                    )
                    for li in items:
                        op.upsert(
                            table="line_items",
                            data=processor.process_line_item(li, cid),
                        )
                        total_li += 1
            op.upsert(
                table="sync_metadata",
                data=processor.sync_meta("line_items", total_li),
            )
            log.info(f"Synced line items: {total_li}")

        # Creatives
        if cfg.enable_creatives_sync:
            total_cr = 0
            for cid in campaign_ids:
                for page_payload in _iter_paginated(
                    client.list_creatives, campaign_id=cid
                ):
                    items = (
                        page_payload.get("items") or page_payload.get("creatives") or []
                    )
                    for cr in items:
                        op.upsert(
                            table="creatives", data=processor.process_creative(cr, cid)
                        )
                        total_cr += 1
            op.upsert(
                table="sync_metadata",
                data=processor.sync_meta("creatives", total_cr),
            )
            log.info(f"Synced creatives: {total_cr}")

    # Checkpoint state
    now_iso = datetime.now().isoformat()
    new_state = {"last_sync_time": now_iso}
    op.checkpoint(new_state)
    log.info("Adform connector sync completed successfully")


# Create connector object
connector = Connector(update=update, schema=schema)

if __name__ == "__main__":
    with open("configuration.json", "r") as f:
        configuration = json.load(f)
    connector.debug(configuration=configuration)
